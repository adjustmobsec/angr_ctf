Todo:

- redo or remove 07, pushing anything to the heap probably doesn't need to be taught
  perhaps rename to "use_memory" or something to teach that you can use arbitrary
  memory addresses

Ideas:

- return oriented programming (search blocks using angr to construct stack automatically)
- loading from a core dump

Deployment/hosting:

let generate.py =
  generates an executable for a given challenge
  args: integer, file_path
  args[0] is the seed to generate the executable. while executables can (and should)
          change even with the same seed, any 'good enough' solution that solves one
          binary generated with seed s should also be able to solve any binary
          generated with seed s.
  args[1] is the file_path that specifies where the binary should be written to.

let package.py =
  generates a zip file containing all files that should be distributed for a given
  challenge
  args: file_path
  args[0] is the file_path to where the zip should be created and written 

let solve.py =
  solves a given executable. this will be defined by the user for each challenge.
  args: file_path
  args[0] is the file_path to the executable it should solve

let test_solution.py = 
  runs an uploaded solve.py on a set of executables for a given challenge, generated
  with generate.py. solve.py should be sandboxed when run. prints results to stdout.
  args: file_path, file_path
  args[0] is the file_path to the python script it should test
  args[1] is the file_path to the executable it should test

download [challenge]:
  call package.py for given challenge
  send the output

test_solution [challenge] [solve_script]:
  call generate.py to generate a set of executables for given challenge
  call test_solution.py on each generated executable with given solve_script
  send the output
