You have access to a server at Eve Elle Software. One that clearly contains very
sensitive, private information.

Your heart races as you download a PDF labeled 'future plans -- private.'

The first few slides contain various company logos and titles, nothing interest-
ing.

The fifth slide, however, has more text. Your eyes widen with disbelief as you
read the first few words: 'step 1: terminate and replace the 10,000 lowest per-
forming employees.' That's half of their staff.

Suddenly, something catches your eye. In the background, the terminal that is
currently logged into their server displays the results of a 'find' search to
locate files with 'private' in their filename. At the bottom of the list, you
see, in small white letters, your name, ending with a .pdf.

You look away. Perhaps you are hallucinating. After all, you haven't gotten much
sleep in the past few days. Your gaze returns to the monitor. Your name shines
back at you, in a staring contest that you cannot win. Slowly, you type the
command to copy the file off of the server and download it to your local mach-
ine. It arrives over the network moments later.

You double click on the icon in your home folder, where you saved it. The PDF
viewer logo begins to bounce at the bottom of your screen.

- Could not open file, encrypted.

You stare in disbelief. Why would Eve Elle Software have a file on you? You
don't work for the company. You can only think of one person who works there,
a classmate from when you were an undergrad. You haven't spoken to him since
you graduated. It isn't him.

It's Jeff.

You want to dig more. Luckily, you find a few binaries that might give you a
way to access a different server, one that might have the encryption key, and
possibly other information.

A first inspection reveals that these binaries seem completely secure. There is
a function that invokes a backdoor, but it isn't called anywhere. Perhaps you
could craft a buffer overflow attack? You aren't sure, and you don't particular-
ly want to manually determine if you can, and then design one.

Angr will probably do the trick.

The internet reveals some interesting information:

- Typically, when Angr branches, it follows one of two paths. Occasionally, in
- rare conditions, there may be multiple paths it can choose to follow at a sin-
- gle instruction. If Angr determines that there are not a few, but rather, an
- infinite (within the bounds of a computer) number of paths that the engine
- can take, it classifies the state as an 'unconstrained' state. That is, there
- is no constraint restricting its next action; it can jump anywhere. Typically,
- this arises from bugs, either in Angr, in your Angr script, or in the program
- you are analyzing. In the case where the instruction pointer, eip on a 32 bit
- architecture, becomes symbolic and able to take on any value, the state will
- have an infinite number of branches it can take. If this is the case, eip can
- be controlled by the user, and may be able to be exploited to jump to an arbit-
- rary location.

You feel good about this. It just might work.
